
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cincinnati: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lmzuccarelli/golang-oci-mirror/pkg/cincinnati/cincinnati.go (79.9%)</option>
				
				<option value="file1">github.com/lmzuccarelli/golang-oci-mirror/pkg/cincinnati/client.go (76.9%)</option>
				
				<option value="file2">github.com/lmzuccarelli/golang-oci-mirror/pkg/cincinnati/find.go (95.8%)</option>
				
				<option value="file3">github.com/lmzuccarelli/golang-oci-mirror/pkg/config/defaults.go (100.0%)</option>
				
				<option value="file4">github.com/lmzuccarelli/golang-oci-mirror/pkg/config/load.go (46.9%)</option>
				
				<option value="file5">github.com/lmzuccarelli/golang-oci-mirror/pkg/config/validate.go (95.0%)</option>
				
				<option value="file6">github.com/lmzuccarelli/golang-oci-mirror/pkg/services/batch.go (0.0%)</option>
				
				<option value="file7">github.com/lmzuccarelli/golang-oci-mirror/pkg/services/channels.go (0.0%)</option>
				
				<option value="file8">github.com/lmzuccarelli/golang-oci-mirror/pkg/services/collector.go (79.7%)</option>
				
				<option value="file9">github.com/lmzuccarelli/golang-oci-mirror/pkg/services/executor.go (0.0%)</option>
				
				<option value="file10">github.com/lmzuccarelli/golang-oci-mirror/pkg/services/operators.go (0.0%)</option>
				
				<option value="file11">github.com/lmzuccarelli/golang-oci-mirror/pkg/services/options.go (0.0%)</option>
				
				<option value="file12">github.com/lmzuccarelli/golang-oci-mirror/pkg/services/release.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cincinnati

import (
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "os"
        "regexp"
        "sort"
        "strings"
        "time"

        "github.com/blang/semver/v4"
        "k8s.io/klog/v2"
)

const (
        // GraphMediaType is the media-type specified in the HTTP Accept header
        // of requests sent to the Cincinnati-v1 Graph API.
        GraphMediaType = "application/json"

        // Timeout when calling upstream Cincinnati stack.
        getUpdatesTimeout = time.Minute * 60
        // UpdateURL is the Cincinnati endpoint for the OpenShift platform.
        UpdateURL = "https://api.openshift.com/api/upgrades_info/v1/graph"
        // OkdUpdateURL is the Cincinnati endpoint for the OKD platform.
        OkdUpdateURL = "https://origin-release.ci.openshift.org/graph"
)

// Error is returned when are unable to get updates.
type Error struct {
        // Reason is the reason suggested for the Cincinnati calculation error.
        Reason string

        // Message is the message suggested for Cincinnati calculation error..
        Message string

        // cause is the upstream error, if any, being wrapped by this error.
        cause error
}

// Error serializes the error as a string, to satisfy the error interface.
func (err *Error) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s: %s", err.Reason, err.Message)
}</span>

// Update is a single node from the update graph.
type Update node

// GetUpdates fetches the requested update payload from the specified
// upstream Cincinnati stack given the current version, architecture, and channel.
// The shortest path is calculated between the current and requested version from the graph edge
// data.
func GetUpdates(ctx context.Context, c Client, arch string, channel string, version semver.Version, reqVer semver.Version) (Update, Update, []Update, error) <span class="cov8" title="1">{
        var current Update
        var requested Update
        // Prepare parametrized cincinnati query.
        c.SetQueryParams(arch, channel, version.String())

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return Update{}, Update{}, nil, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf("version %s in channel %s: %v", version.String(), channel, err),
                        cause:   err,
                }
        }</span>

        // Find the current version within the graph.
        <span class="cov8" title="1">var currentIdx int
        found := false
        for i, node := range graph.Nodes </span><span class="cov8" title="1">{
                if version.EQ(node.Version) </span><span class="cov8" title="1">{
                        currentIdx = i
                        current = Update(graph.Nodes[i])
                        found = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return current, requested, nil, &amp;Error{
                        Reason:  "VersionNotFound",
                        Message: fmt.Sprintf("current version %s not found in the %q channel", version, channel),
                }
        }</span>

        <span class="cov8" title="1">var destinationIdx int
        found = false
        for i, node := range graph.Nodes </span><span class="cov8" title="1">{
                if reqVer.EQ(node.Version) </span><span class="cov8" title="1">{
                        destinationIdx = i
                        requested = Update(graph.Nodes[i])
                        found = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return current, requested, nil, &amp;Error{
                        Reason:  "VersionNotFound",
                        Message: fmt.Sprintf("requested version %s not found in the %q channel", reqVer, channel),
                }
        }</span>

        <span class="cov8" title="1">edgesByOrigin := make(map[int][]int, len(graph.Nodes))
        for _, edge := range graph.Edges </span><span class="cov8" title="1">{
                edgesByOrigin[edge.Origin] = append(edgesByOrigin[edge.Origin], edge.Destination)
        }</span>

        // Sort destination by semver to ensure deterministic result
        <span class="cov8" title="1">for origin, destinations := range edgesByOrigin </span><span class="cov8" title="1">{
                sort.Slice(destinations, func(i, j int) bool </span><span class="cov8" title="1">{
                        return graph.Nodes[destinations[i]].Version.GT(graph.Nodes[destinations[j]].Version)
                }</span>)
                <span class="cov8" title="1">edgesByOrigin[origin] = destinations</span>
        }

        <span class="cov8" title="1">shortestPath := func(g map[int][]int, start, end int) []int </span><span class="cov8" title="1">{
                prev := map[int]int{}
                visited := map[int]struct{}{}
                queue := []int{start}
                visited[start] = struct{}{}
                prev[start] = -1

                for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                        node := queue[0]
                        queue = queue[1:]
                        if node == end </span><span class="cov8" title="1">{
                                break</span>
                        }

                        <span class="cov8" title="1">for _, neighbor := range g[node] </span><span class="cov8" title="1">{
                                if _, ok := visited[neighbor]; !ok </span><span class="cov8" title="1">{
                                        prev[neighbor] = node
                                        queue = append(queue, neighbor)
                                        visited[neighbor] = struct{}{}
                                }</span>
                        }
                }

                // No path to end
                <span class="cov8" title="1">if _, ok := visited[end]; !ok </span><span class="cov8" title="1">{
                        return []int{}
                }</span>

                <span class="cov8" title="1">path := []int{end}
                for next := prev[end]; next != -1; next = prev[next] </span><span class="cov8" title="1">{
                        path = append(path, next)
                }</span>

                // Reverse path.
                <span class="cov8" title="1">for i, j := 0, len(path)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                        path[i], path[j] = path[j], path[i]
                }</span>

                <span class="cov8" title="1">return path</span>
        }

        <span class="cov8" title="1">nextIdxs := shortestPath(edgesByOrigin, currentIdx, destinationIdx)

        var updates []Update
        for _, i := range nextIdxs </span><span class="cov8" title="1">{
                updates = append(updates, Update(graph.Nodes[i]))
        }</span>

        <span class="cov8" title="1">return current, requested, updates, nil</span>
}

// CalculateUpgrades fetches and calculates all the update payloads from the specified
// upstream Cincinnati stack given the current and target version and channel.
func CalculateUpgrades(ctx context.Context, c Client, arch, sourceChannel, targetChannel string, startVer, reqVer semver.Version) (Update, Update, []Update, error) <span class="cov8" title="1">{
        if sourceChannel == targetChannel </span><span class="cov0" title="0">{
                return GetUpdates(ctx, c, arch, targetChannel, startVer, reqVer)
        }</span>

        // Check the major and minor versions are the same with different
        // channel prefixes
        <span class="cov8" title="1">source, target, _, err := getSemverFromChannels(sourceChannel, targetChannel)
        if err != nil </span><span class="cov0" title="0">{
                return Update{}, Update{}, nil, err
        }</span>
        <span class="cov8" title="1">if source.EQ(target) </span><span class="cov8" title="1">{
                isBlocked, err := handleBlockedEdges(ctx, c, arch, targetChannel, startVer)
                if err != nil </span><span class="cov0" title="0">{
                        return Update{}, Update{}, nil, err
                }</span>
                <span class="cov8" title="1">if isBlocked </span><span class="cov0" title="0">{
                        // If blocked path is found, just return the requested version and any accumulated
                        // upgrades to the caller
                        klog.Warningf("No upgrade path for %s in target channel %s", startVer.String(), targetChannel)
                        return GetUpdates(ctx, c, arch, targetChannel, reqVer, reqVer)
                }</span>
                <span class="cov8" title="1">return GetUpdates(ctx, c, arch, targetChannel, startVer, reqVer)</span>
        }

        // Perform initial calculation for the source channel and
        // recurse through the rest until the target or a blocked
        // edge is hit.
        <span class="cov8" title="1">latest, err := GetChannelMinOrMax(ctx, c, arch, sourceChannel, false)
        if err != nil </span><span class="cov0" title="0">{
                return Update{}, Update{}, nil, fmt.Errorf("channel %q: %v", sourceChannel, err)
        }</span>
        <span class="cov8" title="1">current, _, upgrades, err := GetUpdates(ctx, c, arch, sourceChannel, startVer, latest)
        if err != nil </span><span class="cov8" title="1">{
                return Update{}, Update{}, nil, fmt.Errorf("channel %q: %v", sourceChannel, err)
        }</span>

        <span class="cov8" title="1">requested, newUpgrades, err := calculate(ctx, c, arch, sourceChannel, targetChannel, latest, reqVer)
        if err != nil </span><span class="cov8" title="1">{
                return Update{}, Update{}, nil, err
        }</span>
        <span class="cov8" title="1">upgrades = append(upgrades, newUpgrades...)

        var finalUpgrades []Update
        seen := make(map[string]struct{}, len(upgrades))
        for _, upgrade := range upgrades </span><span class="cov8" title="1">{
                if _, ok := seen[upgrade.Image]; !ok </span><span class="cov8" title="1">{
                        finalUpgrades = append(finalUpgrades, upgrade)
                        seen[upgrade.Image] = struct{}{}
                }</span>
        }

        <span class="cov8" title="1">return current, requested, finalUpgrades, nil</span>
}

// calculate will calculate Cincinnati upgrades between channels by finding the latest versions in the source channels
// and incrementing the minor version until the target channel is reached.
func calculate(ctx context.Context, c Client, arch, sourceChannel, targetChannel string, startVer, reqVer semver.Version) (requested Update, upgrades []Update, err error) <span class="cov8" title="1">{
        source, target, prefix, err := getSemverFromChannels(sourceChannel, targetChannel)
        if err != nil </span><span class="cov0" title="0">{
                return requested, upgrades, err
        }</span>
        // We immediately bump the source channel since current source channel upgrades have
        // already been calculated
        <span class="cov8" title="1">source.Minor++
        currChannel := fmt.Sprintf("%s-%v.%v", prefix, source.Major, source.Minor)

        var targetVer semver.Version
        if source.EQ(target) </span><span class="cov8" title="1">{
                // If this is the target channel major.minor get
                // requested version, so we don't exceed the maximum version
                // Set the target channel to make sure we have the intended
                // channel prefix
                targetVer = reqVer
                currChannel = targetChannel
        }</span> else<span class="cov8" title="1"> {
                targetVer, err = GetChannelMinOrMax(ctx, c, arch, currChannel, false)
                if err != nil </span><span class="cov0" title="0">{
                        return requested, upgrades, err
                }</span>
        }

        <span class="cov8" title="1">isBlocked, err := handleBlockedEdges(ctx, c, arch, currChannel, startVer)
        if err != nil </span><span class="cov0" title="0">{
                return requested, upgrades, err
        }</span>
        <span class="cov8" title="1">if isBlocked </span><span class="cov8" title="1">{
                // If blocked path is found, just return the requested version and any accumulated
                // upgrades to the caller
                _, requested, _, err = GetUpdates(ctx, c, arch, targetChannel, targetVer, targetVer)
                //Warnf is 5?
                klog.Warningf("No upgrade path for %s in target channel %s", startVer.String(), targetChannel)
                return requested, upgrades, err
        }</span>

        <span class="cov8" title="1">klog.V(1).Infof("Getting updates for version %s in channel %s", startVer.String(), currChannel)
        _, requested, upgrades, err = GetUpdates(ctx, c, arch, currChannel, startVer, targetVer)
        if err != nil </span><span class="cov0" title="0">{
                return requested, upgrades, err
        }</span>

        <span class="cov8" title="1">if source.EQ(target) </span><span class="cov8" title="1">{
                return requested, upgrades, nil
        }</span>

        <span class="cov8" title="1">currRequested, currUpgrades, err := calculate(ctx, c, arch, currChannel, targetChannel, targetVer, reqVer)
        if err != nil </span><span class="cov0" title="0">{
                return requested, upgrades, err
        }</span>
        <span class="cov8" title="1">requested = currRequested
        upgrades = append(upgrades, currUpgrades...)

        return requested, upgrades, nil</span>
}

// handleBlockedEdges will check for the starting version in the current channel
// if it does not exist the version is blocked.
func handleBlockedEdges(ctx context.Context, c Client, arch, targetChannel string, startVer semver.Version) (bool, error) <span class="cov8" title="1">{
        chanVersions, err := GetVersions(ctx, c, arch, targetChannel)
        if err != nil </span><span class="cov0" title="0">{
                return true, err
        }</span>
        <span class="cov8" title="1">for _, v := range chanVersions </span><span class="cov8" title="1">{
                if v.EQ(startVer) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }
        <span class="cov8" title="1">return true, nil</span>
}

// getSemverFromChannel will return the major and minor version from the source and target channels. The prefix returned is
// for the source channels for cross channel calculations.
func getSemverFromChannels(sourceChannel, targetChannel string) (source, target semver.Version, prefix string, err error) <span class="cov8" title="1">{
        // Get semver representation of source and target channel versions
        sourceIdx := strings.LastIndex(sourceChannel, "-")
        if sourceIdx == -1 </span><span class="cov0" title="0">{
                return source, target, prefix, fmt.Errorf("invalid channel name %s", sourceChannel)
        }</span>
        <span class="cov8" title="1">targetIdx := strings.LastIndex(targetChannel, "-")
        if targetIdx == -1 </span><span class="cov8" title="1">{
                return source, target, prefix, fmt.Errorf("invalid channel name %s", targetChannel)
        }</span>
        <span class="cov8" title="1">source, err = semver.Parse(fmt.Sprintf("%s.0", sourceChannel[sourceIdx+1:]))
        if err != nil </span><span class="cov0" title="0">{
                return source, target, prefix, err
        }</span>
        <span class="cov8" title="1">target, err = semver.Parse(fmt.Sprintf("%s.0", targetChannel[targetIdx+1:]))
        if err != nil </span><span class="cov0" title="0">{
                return source, target, prefix, err
        }</span>
        <span class="cov8" title="1">prefix = sourceChannel[:sourceIdx]
        return source, target, prefix, nil</span>
}

// GetChannelMinOrMax fetches the minimum or maximum version from the specified
// upstream Cincinnati stack given architecture and channel.
func GetChannelMinOrMax(ctx context.Context, c Client, arch string, channel string, min bool) (semver.Version, error) <span class="cov8" title="1">{
        // Prepare parametrized cincinnati query.
        c.SetQueryParams(arch, channel, "")

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return semver.Version{}, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf("channel %q: %v", channel, err),
                        cause:   err,
                }
        }</span>

        // Find the all versions within the graph.
        <span class="cov8" title="1">var versionMatcher *regexp.Regexp
        if versionFilter := os.Getenv("VERSION_FILTER"); len(versionFilter) != 0 </span><span class="cov0" title="0">{
                klog.Info("Usage of the VERSION_FILTER environment variable is unsupported")
                versionMatcher, err = regexp.Compile(versionFilter)
                if err != nil </span><span class="cov0" title="0">{
                        return semver.Version{}, &amp;Error{
                                Reason:  "InvalidVersionFilter",
                                Message: fmt.Sprintf("Version filter '%s' is not a valid regular expression", versionFilter),
                                cause:   err,
                        }
                }</span>
        }

        <span class="cov8" title="1">var Vers []semver.Version
        for _, node := range graph.Nodes </span><span class="cov8" title="1">{
                if versionMatcher == nil || versionMatcher.MatchString(node.Version.String()) </span><span class="cov8" title="1">{
                        Vers = append(Vers, node.Version)
                }</span>
        }

        <span class="cov8" title="1">semver.Sort(Vers)

        if len(Vers) == 0 </span><span class="cov0" title="0">{
                return semver.Version{}, &amp;Error{
                        Reason:  "NoVersionsFound",
                        Message: fmt.Sprintf("no cluster versions found for %q in the %q channel", arch, channel),
                }
        }</span>

        <span class="cov8" title="1">if min </span><span class="cov8" title="1">{
                return Vers[0], nil
        }</span>

        <span class="cov8" title="1">return Vers[len(Vers)-1], nil</span>
}

// GetChannels fetches the channels containing update payloads from the specified
// upstream Cincinnati stack.
func GetChannels(ctx context.Context, c Client, channel string) (map[string]struct{}, error) <span class="cov0" title="0">{
        // Prepare parametrized cincinnati query.
        c.SetQueryParams("", channel, "")

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf("channel %q: %v", channel, err),
                        cause:   err,
                }
        }</span>

        <span class="cov0" title="0">channels := make(map[string]struct{})

        for _, node := range graph.Nodes </span><span class="cov0" title="0">{
                values := node.Metadata["io.openshift.upgrades.graph.release.channels"]

                for _, value := range strings.Split(values, ",") </span><span class="cov0" title="0">{
                        channels[value] = struct{}{}
                }</span>
        }

        <span class="cov0" title="0">return channels, nil</span>
}

// GetVersions will return all update payloads from the specified
// upstream Cincinnati stack given architecture and channel.
func GetVersions(ctx context.Context, c Client, arch, channel string) ([]semver.Version, error) <span class="cov8" title="1">{
        // Prepare parametrized cincinnati query.
        c.SetQueryParams(arch, channel, "")

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf("channel %q: %v", channel, err),
                        cause:   err,
                }
        }</span>
        // Find the all versions within the graph.
        <span class="cov8" title="1">var Vers []semver.Version
        for _, node := range graph.Nodes </span><span class="cov8" title="1">{

                Vers = append(Vers, node.Version)
        }</span>

        <span class="cov8" title="1">if len(Vers) == 0 </span><span class="cov8" title="1">{
                return nil, &amp;Error{
                        Reason:  "NoVersionsFound",
                        Message: fmt.Sprintf("no cluster versions found in the %q channel", channel),
                }
        }</span>

        <span class="cov8" title="1">semver.Sort(Vers)

        return Vers, nil</span>
}

// GetUpdatesInRange will return all update payload within a semver range for a specified channel and architecture.
func GetUpdatesInRange(ctx context.Context, c Client, channel, arch string, updateRange semver.Range) ([]Update, error) <span class="cov8" title="1">{
        // Prepare parametrized cincinnati query.
        c.SetQueryParams(arch, channel, "")

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf("channel %q: %v", channel, err),
                        cause:   err,
                }
        }</span>

        // Find the all updates within the range
        <span class="cov8" title="1">var updates []Update
        for _, node := range graph.Nodes </span><span class="cov8" title="1">{
                if updateRange(node.Version) </span><span class="cov8" title="1">{
                        updates = append(updates, Update(node))
                }</span>

        }
        <span class="cov8" title="1">return updates, nil</span>
}

// getGraphData fetches the update graph from the upstream Cincinnati stack given the current version and channel
func getGraphData(ctx context.Context, c Client) (graph graph, err error) <span class="cov8" title="1">{
        transport := c.GetTransport()
        uri := c.GetURL()
        // Download the update graph.
        req, err := http.NewRequest("GET", uri.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "InvalidRequest", Message: err.Error(), cause: err}
        }</span>
        <span class="cov8" title="1">req.Header.Add("Accept", GraphMediaType)
        if transport != nil &amp;&amp; transport.TLSClientConfig != nil </span><span class="cov0" title="0">{
                if c.GetTransport().TLSClientConfig.ClientCAs == nil </span><span class="cov0" title="0">{
                        klog.V(5).Infof("Using a root CA pool with 0 root CA subjects to request updates from %s", uri)
                }</span> else<span class="cov0" title="0"> {

                        klog.V(5).Infof("Using a root CA pool with %n root CA subjects to request updates from %s", len(transport.TLSClientConfig.RootCAs.Subjects()), uri)
                }</span>
        }

        <span class="cov8" title="1">if transport != nil &amp;&amp; transport.Proxy != nil </span><span class="cov0" title="0">{
                proxy, err := transport.Proxy(req)
                if err == nil &amp;&amp; proxy != nil </span><span class="cov0" title="0">{
                        klog.Infof("Using proxy %s to request updates from %s", proxy.Host, uri)
                }</span>
        }

        <span class="cov8" title="1">client := http.Client{}
        if transport != nil </span><span class="cov8" title="1">{
                client.Transport = transport
        }</span>
        <span class="cov8" title="1">timeoutCtx, cancel := context.WithTimeout(ctx, getUpdatesTimeout)
        defer cancel()
        resp, err := client.Do(req.WithContext(timeoutCtx))
        if err != nil </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "RemoteFailed", Message: err.Error(), cause: err}
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "ResponseFailed", Message: fmt.Sprintf("unexpected HTTP status: %s", resp.Status)}
        }</span>

        // Parse the graph.
        <span class="cov8" title="1">body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "ResponseFailed", Message: err.Error(), cause: err}
        }</span>

        <span class="cov8" title="1">if err = json.Unmarshal(body, &amp;graph); err != nil </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "ResponseInvalid", Message: err.Error(), cause: err}
        }</span>

        <span class="cov8" title="1">return graph, nil</span>
}

type graph struct {
        Nodes []node
        Edges []edge
}

type node struct {
        Version  semver.Version    `json:"version"`
        Image    string            `json:"payload"`
        Metadata map[string]string `json:"metadata,omitempty"`
}

type edge struct {
        Origin      int
        Destination int
}

// UnmarshalJSON unmarshals an edge in the update graph. The edge's JSON
// representation is a two-element array of indices, but Go's representation is
// a struct with two elements so this custom unmarshal method is required.
func (e *edge) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var fields []int
        if err := json.Unmarshal(data, &amp;fields); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(fields) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("expected 2 fields, found %d", len(fields))
        }</span>

        <span class="cov8" title="1">e.Origin = fields[0]
        e.Destination = fields[1]

        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cincinnati

import (
        "crypto/tls"
        "crypto/x509"
        "net/http"
        "net/url"
        "os"

        "github.com/google/uuid"
        "k8s.io/klog/v2"
)

// Client is a Cincinnati client which can be used to fetch update graphs from
// an upstream Cincinnati stack.
type Client interface {
        GetURL() *url.URL
        SetQueryParams(arch, channel, version string)
        GetID() uuid.UUID
        GetTransport() *http.Transport
}

var _ Client = &amp;ocpClient{}

type ocpClient struct {
        id        uuid.UUID
        transport *http.Transport
        url       url.URL
}

// NewOCPClient creates a new OCP Cincinnati client with the given client identifier.
func NewOCPClient(id uuid.UUID) (Client, error) <span class="cov8" title="1">{
        var updateGraphURL string
        if updateURLOverride := os.Getenv("UPDATE_URL_OVERRIDE"); len(updateURLOverride) != 0 </span><span class="cov0" title="0">{
                klog.Info("Usage of the UPDATE_URL_OVERRIDE environment variable is unsupported")
                updateGraphURL = updateURLOverride
        }</span> else<span class="cov8" title="1"> {
                updateGraphURL = UpdateURL
        }</span>
        <span class="cov8" title="1">upstream, err := url.Parse(updateGraphURL)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;ocpClient{}, err
        }</span>

        <span class="cov8" title="1">tls, err := getTLSConfig()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;ocpClient{}, err
        }</span>

        <span class="cov8" title="1">transport := &amp;http.Transport{
                TLSClientConfig: tls,
                Proxy:           http.ProxyFromEnvironment,
        }
        return &amp;ocpClient{id: id, transport: transport, url: *upstream}, nil</span>
}

func (c *ocpClient) GetURL() *url.URL <span class="cov8" title="1">{
        return &amp;c.url
}</span>

func (c *ocpClient) GetTransport() *http.Transport <span class="cov0" title="0">{
        return c.transport
}</span>

func (c *ocpClient) GetID() uuid.UUID <span class="cov8" title="1">{
        return c.id
}</span>

func (c *ocpClient) SetQueryParams(arch, channel, version string) <span class="cov8" title="1">{
        queryParams := c.url.Query()
        queryParams.Add("id", c.id.String())
        params := map[string]string{
                "arch":    arch,
                "channel": channel,
                "version": version,
        }
        for key, value := range params </span><span class="cov8" title="1">{
                if value != "" </span><span class="cov8" title="1">{
                        queryParams.Add(key, value)
                }</span>
        }
        <span class="cov8" title="1">c.url.RawQuery = queryParams.Encode()</span>
}

var _ Client = &amp;okdClient{}

type okdClient struct {
        id        uuid.UUID
        transport *http.Transport
        url       url.URL
}

// NewOKDClient creates a new OKD Cincinnati client with the given client identifier.
func NewOKDClient(id uuid.UUID) (Client, error) <span class="cov8" title="1">{
        upstream, err := url.Parse(OkdUpdateURL)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;okdClient{}, err
        }</span>

        <span class="cov8" title="1">tls, err := getTLSConfig()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;okdClient{}, err
        }</span>

        <span class="cov8" title="1">transport := &amp;http.Transport{
                TLSClientConfig: tls,
                Proxy:           http.ProxyFromEnvironment,
        }
        return &amp;okdClient{id: id, transport: transport, url: *upstream}, nil</span>
}

func (c *okdClient) GetURL() *url.URL <span class="cov8" title="1">{
        return &amp;c.url
}</span>

func (c *okdClient) GetID() uuid.UUID <span class="cov8" title="1">{
        return c.id
}</span>

func (c *okdClient) GetTransport() *http.Transport <span class="cov0" title="0">{
        return c.transport
}</span>

func (c *okdClient) SetQueryParams(_, _, _ string) {<span class="cov8" title="1">
        // Do nothing
}</span>

func getTLSConfig() (*tls.Config, error) <span class="cov8" title="1">{
        certPool, err := x509.SystemCertPool()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">config := &amp;tls.Config{
                RootCAs:    certPool,
                MinVersion: tls.VersionTLS12,
        }
        return config, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cincinnati

import (
        "errors"
        "sort"

        "github.com/blang/semver/v4"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha2"
)

// ErrNoPreviousRelease is returned when no releases can be found in the
// release channels.
var ErrNoPreviousRelease = errors.New("no previous release downloads detected")

// FindRelease will find the minimum or maximum release for a set of ReleaseChannels
func FindRelease(channels []v1alpha2.ReleaseChannel, min bool) (string, semver.Version, error) <span class="cov8" title="1">{
        vers, err := findReleases(channels, min)
        if err != nil </span><span class="cov8" title="1">{
                return "", semver.Version{}, err
        }</span>

        <span class="cov8" title="1">keys := make([]string, 0, len(vers))
        for k := range vers </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">if min </span><span class="cov8" title="1">{
                sort.Slice(keys, func(i, j int) bool </span><span class="cov8" title="1">{
                        return vers[keys[i]].GT(vers[keys[j]])
                }</span>)
        } else<span class="cov8" title="1"> {
                sort.Slice(keys, func(i, j int) bool </span><span class="cov8" title="1">{
                        return vers[keys[i]].LT(vers[keys[j]])
                }</span>)
        }

        <span class="cov8" title="1">return keys[len(keys)-1], vers[keys[len(keys)-1]], nil</span>
}

func findReleases(channels []v1alpha2.ReleaseChannel, min bool) (map[string]semver.Version, error) <span class="cov8" title="1">{
        vers := make(map[string]semver.Version, len(channels))
        if len(channels) == 0 </span><span class="cov8" title="1">{
                return vers, ErrNoPreviousRelease
        }</span>

        <span class="cov8" title="1">for _, ch := range channels </span><span class="cov8" title="1">{

                ver := ch.MaxVersion
                if min </span><span class="cov8" title="1">{
                        ver = ch.MinVersion
                }</span>
                <span class="cov8" title="1">parsedVer, err := semver.Parse(ver)
                if err != nil </span><span class="cov0" title="0">{
                        return vers, err
                }</span>
                <span class="cov8" title="1">vers[ch.Name] = parsedVer</span>
        }

        <span class="cov8" title="1">return vers, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha2"
)

// Complete set default values in the ImageSetConfiguration
// when applicable
func Complete(cfg *v1alpha2.ImageSetConfiguration) <span class="cov8" title="1">{
        completeReleaseArchitectures(cfg)
}</span>

func completeReleaseArchitectures(cfg *v1alpha2.ImageSetConfiguration) <span class="cov8" title="1">{
        if len(cfg.Mirror.Platform.Channels) != 0 &amp;&amp; len(cfg.Mirror.Platform.Architectures) == 0 </span><span class="cov8" title="1">{
                cfg.Mirror.Platform.Architectures = []string{v1alpha2.DefaultPlatformArchitecture}
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "bytes"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/yaml"

        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha2"
)

// TODO(estroz): create interface scheme such that configuration and metadata
// versions do not matter to the caller.
// See https://github.com/kubernetes-sigs/controller-runtime/blob/master/pkg/config/config.go

// ReadConfig opens an imageset configuration file at the given path
// and loads it into a v1alpha2.ImageSetConfiguration instance for processing and validation.
func ReadConfig(configPath string) (c v1alpha2.ImageSetConfiguration, err error) <span class="cov0" title="0">{

        data, err := os.ReadFile(filepath.Clean(configPath))
        if err != nil </span><span class="cov0" title="0">{
                return c, err
        }</span>
        <span class="cov0" title="0">typeMeta, err := getTypeMeta(data)

        if err != nil </span><span class="cov0" title="0">{
                return c, err
        }</span>

        <span class="cov0" title="0">switch typeMeta.GroupVersionKind() </span>{
        case v1alpha2.GroupVersion.WithKind(v1alpha2.ImageSetConfigurationKind):<span class="cov0" title="0">
                c, err = LoadConfig(data)
                if err != nil </span><span class="cov0" title="0">{
                        return c, err
                }</span>
        default:<span class="cov0" title="0">
                return c, fmt.Errorf("config GVK not recognized: %s", typeMeta.GroupVersionKind())</span>
        }

        <span class="cov0" title="0">Complete(&amp;c)

        return c, Validate(&amp;c)</span>
}

// LoadConfig loads data into a v1alpha2.ImageSetConfiguration instance
func LoadConfig(data []byte) (c v1alpha2.ImageSetConfiguration, err error) <span class="cov8" title="1">{

        gvk := v1alpha2.GroupVersion.WithKind(v1alpha2.ImageSetConfigurationKind)

        if data, err = yaml.YAMLToJSON(data); err != nil </span><span class="cov0" title="0">{
                return c, fmt.Errorf("yaml to json %s: %v", gvk, err)
        }</span>

        <span class="cov8" title="1">dec := json.NewDecoder(bytes.NewBuffer(data))
        dec.DisallowUnknownFields()
        if err := dec.Decode(&amp;c); err != nil </span><span class="cov8" title="1">{
                return c, fmt.Errorf("decode %s: %v", gvk, err)
        }</span>

        <span class="cov8" title="1">c.SetGroupVersionKind(gvk)

        return c, nil</span>
}

// LoadMetadata loads data into a v1alpha2.Metadata instance
func LoadMetadata(data []byte) (m v1alpha2.Metadata, err error) <span class="cov8" title="1">{

        gvk := v1alpha2.GroupVersion.WithKind(v1alpha2.MetadataKind)

        dec := json.NewDecoder(bytes.NewBuffer(data))
        dec.DisallowUnknownFields()
        if err := dec.Decode(&amp;m); err != nil </span><span class="cov8" title="1">{
                return m, fmt.Errorf("decode %s: %v", gvk, err)
        }</span>

        <span class="cov8" title="1">m.SetGroupVersionKind(gvk)

        return m, nil</span>
}

func getTypeMeta(data []byte) (typeMeta metav1.TypeMeta, err error) <span class="cov0" title="0">{
        if err := yaml.Unmarshal(data, &amp;typeMeta); err != nil </span><span class="cov0" title="0">{
                return typeMeta, fmt.Errorf("get type meta: %v", err)
        }</span>
        <span class="cov0" title="0">return typeMeta, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "fmt"

        utilerrors "k8s.io/apimachinery/pkg/util/errors"

        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha2"
)

type validationFunc func(cfg *v1alpha2.ImageSetConfiguration) error

var validationChecks = []validationFunc{validateOperatorOptions, validateReleaseChannels}

// Validate will check an ImagesetConfiguration for input errors.
func Validate(cfg *v1alpha2.ImageSetConfiguration) error <span class="cov8" title="1">{
        var errs []error
        for _, check := range validationChecks </span><span class="cov8" title="1">{
                if err := check(cfg); err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, fmt.Errorf("invalid configuration: %v", err))
                }</span>
        }
        <span class="cov8" title="1">return utilerrors.NewAggregate(errs)</span>
}

func validateOperatorOptions(cfg *v1alpha2.ImageSetConfiguration) error <span class="cov8" title="1">{
        seen := map[string]bool{}
        for _, ctlg := range cfg.Mirror.Operators </span><span class="cov8" title="1">{
                ctlgName, err := ctlg.GetUniqueName()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if seen[ctlgName] </span><span class="cov8" title="1">{
                        return fmt.Errorf(
                                "catalog %q: duplicate found in configuration", ctlgName,
                        )
                }</span>
                <span class="cov8" title="1">seen[ctlgName] = true</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func validateReleaseChannels(cfg *v1alpha2.ImageSetConfiguration) error <span class="cov8" title="1">{
        seen := map[string]bool{}
        for _, channel := range cfg.Mirror.Platform.Channels </span><span class="cov8" title="1">{
                if seen[channel.Name] </span><span class="cov8" title="1">{
                        return fmt.Errorf(
                                "release channel %q: duplicate found in configuration", channel.Name,
                        )
                }</span>
                <span class="cov8" title="1">seen[channel.Name] = true</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package services

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "os"
        "strings"
        "sync"

        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha3"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/mirror"
)

type BatchSchema struct {
        Writer     io.Writer
        copyImages []v1alpha3.RelatedImage
        items      int
        count      int
        batchSize  int
        batchIndex int
        remainder  int
}

func (o *Executor) BatchWorker(ctx context.Context, workload *BatchSchema, opts mirror.CopyOptions) error <span class="cov0" title="0">{

        var errArray []error
        var wg sync.WaitGroup

        writer := bufio.NewWriter(os.Stdout)
        o.Log.Info("images to mirror %d", workload.items)
        o.Log.Info("batch count %d", workload.count)
        o.Log.Info("batch index %d", workload.batchIndex)
        o.Log.Info("batch size %d", workload.batchSize)
        o.Log.Info("remainder size %d", workload.remainder)

        wg.Add(workload.batchSize)
        for i := 0; i &lt; workload.count; i++ </span><span class="cov0" title="0">{
                o.Log.Info(fmt.Sprintf("starting batch %d ", i))
                for x := 0; x &lt; workload.batchSize; x++ </span><span class="cov0" title="0">{
                        index := (i * workload.batchSize) + x
                        irs, err := customImageParser(workload.copyImages[index].Image)
                        if err != nil </span><span class="cov0" title="0">{
                                o.Log.Error("%v", err)
                                continue</span>
                        }
                        // ignore the failure as it will be picked up in the Run
                        <span class="cov0" title="0">err = os.MkdirAll(strings.Split(opts.Destination, ":")[1]+"/"+irs.Namespace, 0750)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">src := dockerProtocol + workload.copyImages[index].Image
                        dest := opts.Destination + "/" + irs.Namespace + "/" + irs.Component

                        o.Log.Debug("source %s ", workload.copyImages[index].Image)
                        o.Log.Debug("destination %s ", opts.Destination+"/"+irs.Namespace+"/"+irs.Component)

                        go func(ctx context.Context, src, dest string, opts *mirror.CopyOptions, writer io.Writer) </span><span class="cov0" title="0">{
                                defer wg.Done()
                                err := o.Mirror.Run(ctx, src, dest, opts, writer)
                                if err != nil </span><span class="cov0" title="0">{
                                        errArray = append(errArray, err)
                                }</span>
                        }(ctx, src, dest, &amp;opts, writer)
                }
                <span class="cov0" title="0">wg.Wait()
                writer.Flush()
                o.Log.Info("completed batch %d", i)
                if workload.count &gt; 1 </span><span class="cov0" title="0">{
                        wg.Add(BATCH_SIZE)
                }</span>
                <span class="cov0" title="0">if len(errArray) &gt; 0 </span><span class="cov0" title="0">{
                        for _, err := range errArray </span><span class="cov0" title="0">{
                                o.Log.Error(" errArray %v", err)
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("error in batch - refer to console logs")</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func customImageParser(image string) (*v1alpha3.ImageRefSchema, error) <span class="cov0" title="0">{
        var irs *v1alpha3.ImageRefSchema
        var component string
        parts := strings.Split(image, "/")
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return irs, fmt.Errorf("image url seems to be wrong %s ", image)
        }</span>
        <span class="cov0" title="0">if strings.Contains(parts[2], "@") </span><span class="cov0" title="0">{
                component = strings.Split(parts[2], "@")[0]
        }</span> else<span class="cov0" title="0"> {
                component = parts[2]
        }</span>
        <span class="cov0" title="0">irs = &amp;v1alpha3.ImageRefSchema{Repository: parts[0], Namespace: parts[1], Component: component}
        return irs, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/blang/semver/v4"
        "github.com/google/uuid"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha2"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/cincinnati"
)

// ReleaseOptions configures either a Full or Diff mirror operation
// on a particular release image.
type ReleaseOptions struct {
        *MirrorOptions
        // insecure indicates whether the source
        // registry is insecure
        insecure bool
        uuid     uuid.UUID
}

// NewReleaseOptions defaults ReleaseOptions.
func NewReleaseOptions(mo *MirrorOptions) *ReleaseOptions <span class="cov0" title="0">{
        relOpts := &amp;ReleaseOptions{
                MirrorOptions: mo,
                uuid:          uuid.New(),
        }
        if mo.SourcePlainHTTP || mo.SourceSkipTLS </span><span class="cov0" title="0">{
                relOpts.insecure = true
        }</span>
        <span class="cov0" title="0">return relOpts</span>
}

func (o *ReleaseOptions) Run(ctx context.Context, cfg *v1alpha2.ImageSetConfiguration) map[string]struct{} <span class="cov0" title="0">{

        var (
                //srcDir           = filepath.Join(o.Dir, config.SourceDir)
                releaseDownloads = downloads{}
                //mmapping         = image.TypedImageMapping{}
                errs = []error{}
        )

        for _, arch := range cfg.Mirror.Platform.Architectures </span><span class="cov0" title="0">{

                versionsByChannel := make(map[string]v1alpha2.ReleaseChannel, len(cfg.Mirror.Platform.Channels))

                for _, ch := range cfg.Mirror.Platform.Channels </span><span class="cov0" title="0">{

                        var client cincinnati.Client
                        var err error
                        switch ch.Type </span>{
                        case v1alpha2.TypeOCP:<span class="cov0" title="0">
                                client, err = cincinnati.NewOCPClient(o.uuid)</span>
                        case v1alpha2.TypeOKD:<span class="cov0" title="0">
                                client, err = cincinnati.NewOKDClient(o.uuid)</span>
                        default:<span class="cov0" title="0">
                                errs = append(errs, fmt.Errorf("invalid platform type %v", ch.Type))
                                continue</span>
                        }
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }

                        <span class="cov0" title="0">if len(ch.MaxVersion) == 0 || len(ch.MinVersion) == 0 </span><span class="cov0" title="0">{

                                // Find channel maximum value and only set the minimum as well if heads-only is true
                                if len(ch.MaxVersion) == 0 </span><span class="cov0" title="0">{
                                        latest, err := cincinnati.GetChannelMinOrMax(ctx, client, arch, ch.Name, false)
                                        if err != nil </span><span class="cov0" title="0">{
                                                errs = append(errs, err)
                                                continue</span>
                                        }

                                        // Update version to release channel
                                        <span class="cov0" title="0">ch.MaxVersion = latest.String()
                                        fmt.Printf("detected minimum version as %s", ch.MaxVersion)
                                        if len(ch.MinVersion) == 0 &amp;&amp; ch.IsHeadsOnly() </span><span class="cov0" title="0">{
                                                //min, found := prevChannels[ch.Name]
                                                //if !found {
                                                // Starting at a new headsOnly channels
                                                min := latest.String()
                                                //}
                                                ch.MinVersion = min
                                                fmt.Printf("detected minimum version as %s\n", ch.MinVersion)
                                        }</span>
                                }

                                // Find channel minimum if full is true or just the minimum is not set
                                // in the config
                                <span class="cov0" title="0">if len(ch.MinVersion) == 0 </span><span class="cov0" title="0">{
                                        first, err := cincinnati.GetChannelMinOrMax(ctx, client, arch, ch.Name, true)
                                        if err != nil </span><span class="cov0" title="0">{
                                                errs = append(errs, err)
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">ch.MinVersion = first.String()
                                        fmt.Printf("detected minimum version as %s\n", ch.MinVersion)</span>
                                }
                                <span class="cov0" title="0">versionsByChannel[ch.Name] = ch</span>
                        } else<span class="cov0" title="0"> {
                                // Range is set. Ensure full is true so this
                                // is skipped when processing release metadata.
                                fmt.Printf("processing minimum version %s and maximum version %s\n", ch.MinVersion, ch.MaxVersion)
                                ch.Full = true
                                versionsByChannel[ch.Name] = ch
                        }</span>

                        <span class="cov0" title="0">downloads, err := o.getChannelDownloads(ctx, client, nil, ch, arch)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">releaseDownloads.Merge(downloads)</span>

                }

                // Update cfg release channels with maximum and minimum versions
                // if applicable
                <span class="cov0" title="0">for i, ch := range cfg.Mirror.Platform.Channels </span><span class="cov0" title="0">{
                        ch, found := versionsByChannel[ch.Name]
                        if found </span><span class="cov0" title="0">{
                                cfg.Mirror.Platform.Channels[i] = ch
                        }</span>
                }

                <span class="cov0" title="0">if len(cfg.Mirror.Platform.Channels) &gt; 1 </span><span class="cov0" title="0">{
                        client, err := cincinnati.NewOCPClient(o.uuid)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">newDownloads, err := o.getCrossChannelDownloads(ctx, client, arch, cfg.Mirror.Platform.Channels)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Errorf("error calculating cross channel upgrades: %v", err))
                                continue</span>
                        }
                        <span class="cov0" title="0">releaseDownloads.Merge(newDownloads)</span>
                }
        }

        <span class="cov0" title="0">return releaseDownloads</span>
}

type downloads map[string]struct{}

func (d downloads) Merge(in downloads) <span class="cov0" title="0">{
        for k, v := range in </span><span class="cov0" title="0">{
                _, ok := d[k]
                if ok </span><span class="cov0" title="0">{
                        fmt.Printf("download %s exists", k)
                        continue</span>
                }
                <span class="cov0" title="0">d[k] = v</span>
        }
}

var b []byte

// getDownloads will prepare the downloads map for mirroring
func (o *ReleaseOptions) getChannelDownloads(ctx context.Context, c cincinnati.Client, lastChannels []v1alpha2.ReleaseChannel, channel v1alpha2.ReleaseChannel, arch string) (downloads, error) <span class="cov0" title="0">{
        allDownloads := downloads{}

        var prevChannel v1alpha2.ReleaseChannel
        for _, ch := range lastChannels </span><span class="cov0" title="0">{
                if ch.Name == channel.Name </span><span class="cov0" title="0">{
                        prevChannel = ch
                }</span>
        }

        <span class="cov0" title="0">if prevChannel.Name != "" </span><span class="cov0" title="0">{
                // If the requested min version is less than the previous, add downloads
                if prevChannel.MinVersion &gt; channel.MinVersion </span><span class="cov0" title="0">{
                        first, err := semver.Parse(channel.MinVersion)
                        if err != nil </span><span class="cov0" title="0">{
                                return allDownloads, err
                        }</span>
                        <span class="cov0" title="0">last, err := semver.Parse(prevChannel.MinVersion)
                        if err != nil </span><span class="cov0" title="0">{
                                return allDownloads, err
                        }</span>
                        <span class="cov0" title="0">current, newest, updates, err := cincinnati.CalculateUpgrades(ctx, c, arch, channel.Name, channel.Name, first, last)
                        if err != nil </span><span class="cov0" title="0">{
                                return allDownloads, err
                        }</span>
                        <span class="cov0" title="0">newDownloads := gatherUpdates(current, newest, updates)
                        allDownloads.Merge(newDownloads)</span>
                }

                // If the requested max version is more than the previous, add downloads
                <span class="cov0" title="0">if prevChannel.MaxVersion &lt; channel.MaxVersion </span><span class="cov0" title="0">{
                        first, err := semver.Parse(prevChannel.MaxVersion)
                        if err != nil </span><span class="cov0" title="0">{
                                return allDownloads, err
                        }</span>
                        <span class="cov0" title="0">last, err := semver.Parse(channel.MinVersion)
                        if err != nil </span><span class="cov0" title="0">{
                                return allDownloads, err
                        }</span>
                        <span class="cov0" title="0">current, newest, updates, err := cincinnati.CalculateUpgrades(ctx, c, arch, channel.Name, channel.Name, first, last)
                        if err != nil </span><span class="cov0" title="0">{
                                return allDownloads, err
                        }</span>
                        <span class="cov0" title="0">newDownloads := gatherUpdates(current, newest, updates)
                        allDownloads.Merge(newDownloads)</span>
                }
        }

        // Plot between min and max of channel
        <span class="cov0" title="0">first, err := semver.Parse(channel.MinVersion)
        if err != nil </span><span class="cov0" title="0">{
                return allDownloads, err
        }</span>
        <span class="cov0" title="0">last, err := semver.Parse(channel.MaxVersion)
        if err != nil </span><span class="cov0" title="0">{
                return allDownloads, err
        }</span>

        <span class="cov0" title="0">var newDownloads downloads
        if channel.ShortestPath </span><span class="cov0" title="0">{
                current, newest, updates, err := cincinnati.CalculateUpgrades(ctx, c, arch, channel.Name, channel.Name, first, last)
                if err != nil </span><span class="cov0" title="0">{
                        return allDownloads, err
                }</span>
                <span class="cov0" title="0">newDownloads = gatherUpdates(current, newest, updates)</span>

        } else<span class="cov0" title="0"> {
                lowRange, err := semver.ParseRange(fmt.Sprintf("&gt;=%s", first))
                if err != nil </span><span class="cov0" title="0">{
                        return allDownloads, err
                }</span>
                <span class="cov0" title="0">highRange, err := semver.ParseRange(fmt.Sprintf("&lt;=%s", last))
                if err != nil </span><span class="cov0" title="0">{
                        return allDownloads, err
                }</span>
                <span class="cov0" title="0">versions, err := cincinnati.GetUpdatesInRange(ctx, c, channel.Name, arch, highRange.AND(lowRange))
                if err != nil </span><span class="cov0" title="0">{
                        return allDownloads, err
                }</span>
                <span class="cov0" title="0">newDownloads = gatherUpdates(cincinnati.Update{}, cincinnati.Update{}, versions)</span>
        }
        <span class="cov0" title="0">allDownloads.Merge(newDownloads)

        return allDownloads, nil</span>
}

// getCrossChannelDownloads will determine required downloads between channel versions (for OCP only)
func (o *ReleaseOptions) getCrossChannelDownloads(ctx context.Context, ocpClient cincinnati.Client, arch string, channels []v1alpha2.ReleaseChannel) (downloads, error) <span class="cov0" title="0">{
        // Strip any OKD channels from the list

        var ocpChannels []v1alpha2.ReleaseChannel
        for _, ch := range channels </span><span class="cov0" title="0">{
                if ch.Type == v1alpha2.TypeOCP </span><span class="cov0" title="0">{
                        ocpChannels = append(ocpChannels, ch)
                }</span>
        }
        // If no other channels exist, return no downloads
        <span class="cov0" title="0">if len(ocpChannels) == 0 </span><span class="cov0" title="0">{
                return downloads{}, nil
        }</span>

        <span class="cov0" title="0">firstCh, first, err := cincinnati.FindRelease(ocpChannels, true)
        if err != nil </span><span class="cov0" title="0">{
                return downloads{}, fmt.Errorf("failed to find minimum release version: %v", err)
        }</span>
        <span class="cov0" title="0">lastCh, last, err := cincinnati.FindRelease(ocpChannels, false)
        if err != nil </span><span class="cov0" title="0">{
                return downloads{}, fmt.Errorf("failed to find maximum release version: %v", err)
        }</span>
        <span class="cov0" title="0">current, newest, updates, err := cincinnati.CalculateUpgrades(ctx, ocpClient, arch, firstCh, lastCh, first, last)
        if err != nil </span><span class="cov0" title="0">{
                return downloads{}, fmt.Errorf("failed to get upgrade graph: %v", err)
        }</span>
        <span class="cov0" title="0">return gatherUpdates(current, newest, updates), nil</span>
}

func gatherUpdates(current, newest cincinnati.Update, updates []cincinnati.Update) downloads <span class="cov0" title="0">{
        releaseDownloads := downloads{}
        for _, update := range updates </span><span class="cov0" title="0">{
                fmt.Printf("Found update %s\n", update.Version)
                releaseDownloads[update.Image] = struct{}{}
        }</span>

        <span class="cov0" title="0">if current.Image != "" </span><span class="cov0" title="0">{
                releaseDownloads[current.Image] = struct{}{}
        }</span>

        <span class="cov0" title="0">if newest.Image != "" </span><span class="cov0" title="0">{
                releaseDownloads[newest.Image] = struct{}{}
        }</span>

        <span class="cov0" title="0">return releaseDownloads</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package services

import (
        "bufio"
        "context"
        "os"
        "strings"

        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha3"
)

const (
        catalogJson string = "catalog.json"
        // TODO: make this global
        operatorImageExtractDir string = "hold-operator"
)

func (o *Executor) OperatorImageCollector(ctx context.Context) ([]v1alpha3.RelatedImage, error) <span class="cov8" title="1">{

        var allRelatedImages []v1alpha3.RelatedImage
        compare := make(map[string]v1alpha3.ISCPackage)
        relatedImages := make(map[string][]v1alpha3.RelatedImage)
        var err error
        label := "configs"

        // compile a map to compare channels,min &amp; max versions
        for _, ops := range o.Config.Mirror.Operators </span><span class="cov8" title="1">{
                o.Log.Info("isc operators: %s\n", ops.Catalog)
                for _, pkg := range ops.Packages </span><span class="cov8" title="1">{
                        o.Log.Info("catalog packages: %s \n", pkg.Name)
                        for _, channel := range pkg.Channels </span><span class="cov8" title="1">{
                                compare[pkg.Name] = v1alpha3.ISCPackage{Channel: channel.Name, MinVersion: channel.MinVersion, MaxVersion: channel.MaxVersion}
                                o.Log.Info("channels: %v \n", compare)
                        }</span>
                }
        }

        // check the mode
        <span class="cov8" title="1">if o.Opts.Mode == mirrorToDisk </span><span class="cov8" title="1">{
                writer := bufio.NewWriter(os.Stdout)
                for _, op := range o.Config.Mirror.Operators </span><span class="cov8" title="1">{

                        if !o.Opts.Dev </span><span class="cov8" title="1">{
                                // download the operator index image
                                o.Log.Info("copying operator image %v", op.Catalog)
                                src := dockerProtocol + op.Catalog
                                dest := ociProtocol + workingDir + operatorImageDir
                                err := o.Mirror.Run(ctx, src, dest, &amp;o.Opts, writer)
                                writer.Flush()
                                if err != nil </span><span class="cov0" title="0">{
                                        o.Log.Error(" %v ", err)
                                }</span>
                                // it's in oci format so we can go directly to the index.json file
                                <span class="cov8" title="1">oci, err := o.Manifest.GetImageIndex(workingDir + operatorImageDir)
                                if err != nil </span><span class="cov0" title="0">{
                                        return []v1alpha3.RelatedImage{}, err
                                }</span>

                                //read the link to the manifest
                                <span class="cov8" title="1">manifest := strings.Split(oci.Manifests[0].Digest, ":")[1]
                                o.Log.Info("manifest %v", manifest)

                                // read the operator image manifest
                                oci, err = o.Manifest.GetImageManifest(workingDir + operatorImageDir + blobsDir + manifest)
                                if err != nil </span><span class="cov0" title="0">{
                                        return []v1alpha3.RelatedImage{}, err
                                }</span>

                                // read the config digest to get the detailed manifest
                                // looking for the lable to search for a specific folder
                                <span class="cov8" title="1">ocs, err := o.Manifest.GetOperatorConfig(workingDir + operatorImageDir + blobsDir + strings.Split(oci.Config.Digest, ":")[1])
                                if err != nil </span><span class="cov0" title="0">{
                                        return []v1alpha3.RelatedImage{}, err
                                }</span>

                                <span class="cov8" title="1">label = ocs.Config.Labels.OperatorsOperatorframeworkIoIndexConfigsV1

                                o.Log.Info("label %s", label)

                                // untar all the blobs for the operator
                                // if the layer with "label (from previous step) is found to a specific folder"
                                err = o.Manifest.ExtractLayersOCI(workingDir+operatorImageDir+blobsDir, label, oci)
                                if err != nil </span><span class="cov0" title="0">{
                                        return []v1alpha3.RelatedImage{}, err
                                }</span>
                        }

                        // select all packages
                        // this is the equivalent of the headOnly mode
                        // only the latest version of each operator will be selected
                        <span class="cov8" title="1">if len(op.Packages) == 0 </span><span class="cov8" title="1">{
                                relatedImages, err = o.Manifest.GetRelatedImagesFromCatalog(operatorImageExtractDir, label)
                                if err != nil </span><span class="cov0" title="0">{
                                        return []v1alpha3.RelatedImage{}, err
                                }</span>
                        } else<span class="cov8" title="1"> {
                                // iterate through each package
                                relatedImages, err = o.Manifest.GetRelatedImagesFromCatalogByFilter(operatorImageExtractDir, label, op, compare)
                                if err != nil </span><span class="cov0" title="0">{
                                        return []v1alpha3.RelatedImage{}, err
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">o.Log.Info("related images length %d ", len(relatedImages))
        var count = 0
        for _, v := range relatedImages </span><span class="cov0" title="0">{
                count = count + len(v)
        }</span>
        <span class="cov8" title="1">o.Log.Info("images to copy (before duplicates) %d ", count)

        // remove all duplicates
        imgs := cleanDuplicates(relatedImages)
        o.Log.Trace("flatenned %v ", imgs)
        o.Log.Debug("images to copy")
        for k, v := range imgs </span><span class="cov0" title="0">{
                o.Log.Debug("  name %s", v)
                o.Log.Debug("  image %s", k)
                allRelatedImages = append(allRelatedImages, v1alpha3.RelatedImage{Name: v, Image: k})
        }</span>
        <span class="cov8" title="1">return allRelatedImages, nil</span>
}

// cleanDuplicates - simple utility to remove duplicates
func cleanDuplicates(m map[string][]v1alpha3.RelatedImage) map[string]string <span class="cov8" title="1">{
        x := make(map[string]string)
        for _, v := range m </span><span class="cov0" title="0">{
                for _, ri := range v </span><span class="cov0" title="0">{
                        x[ri.Image] = ri.Name
                }</span>
        }
        <span class="cov8" title="1">return x</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package services

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        kcmdutil "k8s.io/kubectl/pkg/cmd/util"
        "k8s.io/kubectl/pkg/util/templates"

        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha2"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/config"
        clog "github.com/lmzuccarelli/golang-oci-mirror/pkg/log"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/manifest"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/mirror"
        "github.com/microlib/simple"
        "github.com/spf13/cobra"
)

var (
        mirrorlongDesc = templates.LongDesc(
                ` 
                Create and publish user-configured mirrors with a declarative configuration input.
                used for authenticating to the registries. The podman location for credentials is also supported as a secondary location.

                1. Destination prefix is docker:// - The current working directory will be used.
                2. Destination prefix is oci:// - The destination directory specified will be used.


                TODO:

                `,
        )
        mirrorExamples = templates.Examples(
                `
                # Mirror to a directory
                oc-mirror --config mirror-config.yaml oci:mirror

                TODO:
                `,
        )
)

type Executor struct {
        Log      *clog.CustomLogger
        Mirror   mirror.MirrorInterface
        Manifest manifest.ManifestInterface
        Config   v1alpha2.ImageSetConfiguration
        Opts     mirror.CopyOptions
}

func NewMirrorCmd() *cobra.Command <span class="cov0" title="0">{
        o := MirrorOptions{}

        cmd := &amp;cobra.Command{
                Use: fmt.Sprintf(
                        "%s &lt;destination type&gt;:&lt;destination location&gt;",
                        filepath.Base(os.Args[0]),
                ),
                Short:   "Manage mirrors per user configuration",
                Long:    mirrorlongDesc,
                Example: mirrorExamples,
                //PersistentPreRun:  o.LogfilePreRun,
                //PersistentPostRun: o.LogfilePostRun,
                Args:          cobra.MinimumNArgs(1),
                SilenceErrors: false,
                SilenceUsage:  false,
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        //kcmdutil.CheckErr(o.Complete(cmd, args))
                        kcmdutil.CheckErr(o.Validate(args[0]))
                        kcmdutil.CheckErr(o.Run(cmd, args))
                }</span>,
        }

        <span class="cov0" title="0">o.BindFlags(cmd.Flags())
        return cmd</span>
}

func (o *MirrorOptions) Run(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{

        // setup custom logger
        // feel free to plugin you own logger -just use the Logger struct
        // in the file pkg/services/log.go
        sl := &amp;simple.Logger{Level: "debug"}
        log := &amp;clog.CustomLogger{Log: sl}

        cfg, err := config.ReadConfig(o.ConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("imagesetconfig %v ", err)
        }</span>
        <span class="cov0" title="0">log.Debug("imagesetconfig : %v", cfg)

        global := &amp;mirror.GlobalOptions{Debug: true, TlsVerify: false, InsecurePolicy: true}
        _, sharedOpts := mirror.SharedImageFlags()
        _, deprecatedTLSVerifyOpt := mirror.DeprecatedTLSVerifyFlags()
        _, srcOpts := mirror.ImageFlags(global, sharedOpts, deprecatedTLSVerifyOpt, "src-", "screds")
        _, destOpts := mirror.ImageDestFlags(global, sharedOpts, deprecatedTLSVerifyOpt, "dest-", "dcreds")
        _, retryOpts := mirror.RetryFlags()
        opts := mirror.CopyOptions{
                Global:              global,
                DeprecatedTLSVerify: deprecatedTLSVerifyOpt,
                SrcImage:            srcOpts,
                DestImage:           destOpts,
                RetryOpts:           retryOpts,
                Destination:         args[0],
                Dev:                 false,
        }

        // logic to check mode
        if strings.Contains(args[0], ociProtocol) </span><span class="cov0" title="0">{
                opts.Mode = mirrorToDisk
        }</span> else<span class="cov0" title="0"> if strings.Contains(args[0], dockerProtocol) </span><span class="cov0" title="0">{
                opts.Mode = diskToMirror
        }</span>

        <span class="cov0" title="0">log.Info("mode %s ", opts.Mode)

        executor := &amp;Executor{
                Log:      log,
                Mirror:   mirror.New(),
                Manifest: manifest.New(log),
                Config:   cfg,
                Opts:     opts,
        }

        // ensure working dir exists
        err = os.MkdirAll("working-dir", 0755)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(" %v ", err)
                os.Exit(1)
        }</span>

        // do releases
        <span class="cov0" title="0">if len(cfg.Mirror.Platform.Channels) &gt; 10 </span><span class="cov0" title="0">{
                err = executor.ExecuteRelease(cmd.Context())
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(fmt.Sprintf("executing release copy %v ", err))
                        os.Exit(1)
                }</span>
        }

        // do operators
        <span class="cov0" title="0">if len(cfg.Mirror.Operators) &gt; 0 </span><span class="cov0" title="0">{
                err = executor.ExecuteOperators(cmd.Context())
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(fmt.Sprintf("executing operator copy %v ", err))
                        os.Exit(1)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (o *MirrorOptions) Validate(dest string) error <span class="cov0" title="0">{
        if strings.Contains(dest, "oci:") || strings.Contains(dest, "docker://") </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("destination protocol must be either oci: or docker://")</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package services

import (
        "context"
)

func (o *Executor) ExecuteOperators(ctx context.Context) error <span class="cov0" title="0">{

        allRelatedImages, err := o.OperatorImageCollector(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">o.Log.Info("total images to copy %d ", len(allRelatedImages))

        var batch *BatchSchema
        images := len(allRelatedImages)
        if images &lt; BATCH_SIZE </span><span class="cov0" title="0">{
                batch = &amp;BatchSchema{items: images, count: 1, batchSize: images, batchIndex: 0, remainder: 0}
        }</span> else<span class="cov0" title="0"> {
                batch = &amp;BatchSchema{items: images, count: (images / BATCH_SIZE), batchSize: BATCH_SIZE, remainder: (images % BATCH_SIZE)}
        }</span>
        <span class="cov0" title="0">batch.copyImages = allRelatedImages

        // call the batch executioner
        err = o.BatchWorker(ctx, batch, o.Opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if batch.remainder &gt; 0 </span><span class="cov0" title="0">{
                batch.batchIndex = batch.count
                batch.count = batch.remainder
                batch.batchSize = 1
                err := o.BatchWorker(ctx, batch, o.Opts)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package services

import (
        "context"
        "flag"
        "fmt"
        "io"
        "io/ioutil"
        "os"
        "os/signal"
        "sync"
        "syscall"

        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        "k8s.io/cli-runtime/pkg/genericclioptions"
        "k8s.io/klog/v2"
)

type RootOptions struct {
        genericclioptions.IOStreams
        Dir            string
        LogLevel       int
        logfileCleanup func()
}

func (o *RootOptions) BindFlags(fs *pflag.FlagSet) <span class="cov0" title="0">{
        fs.StringVarP(&amp;o.Dir, "dir", "d", "oc-mirror-workspace", "Assets directory")
        fs.IntVarP(&amp;o.LogLevel, "verbose", "v", o.LogLevel, "Number for the log level verbosity (valid 1-9, default is 0)")
        if err := fs.MarkHidden("dir"); err != nil </span><span class="cov0" title="0">{
                klog.Fatal(err.Error())
        }</span>
}

func (o *RootOptions) LogfilePreRun(cmd *cobra.Command, _ []string) <span class="cov0" title="0">{
        var fsv2 flag.FlagSet
        // Configure klog flags
        klog.InitFlags(&amp;fsv2)
        checkErr(fsv2.Set("stderrthreshold", "4"))
        checkErr(fsv2.Set("skip_headers", "true"))
        checkErr(fsv2.Set("logtostderr", "false"))
        checkErr(fsv2.Set("alsologtostderr", "false"))
        checkErr(fsv2.Set("v", fmt.Sprintf("%d", o.LogLevel)))

        logFile, err := os.OpenFile(".oc-mirror.log", os.O_CREATE|os.O_APPEND|os.O_RDWR, 0600)
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatal(err)
        }</span>

        <span class="cov0" title="0">klog.SetOutput(io.MultiWriter(o.IOStreams.Out, logFile))

        // Setup logrus for use with operator-registry
        logrus.SetOutput(ioutil.Discard)

        var logrusLevel logrus.Level
        switch o.LogLevel </span>{
        case 0:<span class="cov0" title="0">
                logrusLevel = logrus.InfoLevel</span>
        case 1:<span class="cov0" title="0">
                logrusLevel = logrus.DebugLevel</span>
        case 2:<span class="cov0" title="0">
                logrusLevel = logrus.DebugLevel</span>
        default:<span class="cov0" title="0">
                logrusLevel = logrus.TraceLevel</span>
        }

        <span class="cov0" title="0">logrus.SetLevel(logrusLevel)
        //logrus.AddHook(newFileHookWithNewlineTruncate(o.IOStreams.ErrOut, logrusLevel, &amp;logrus.TextFormatter{
        //        DisableTimestamp:       false,
        //                DisableLevelTruncation: true,
        //                DisableQuote:           true,
        //        }))
        //        logrusCleanup := setupFileHook(logFile)

        // Add to root IOStream options
        o.IOStreams = genericclioptions.IOStreams{
                In:     o.IOStreams.In,
                Out:    io.MultiWriter(o.IOStreams.Out, logFile),
                ErrOut: io.MultiWriter(o.IOStreams.ErrOut, logFile),
        }

        o.logfileCleanup = func() </span><span class="cov0" title="0">{
                klog.Flush()
                //                logrusCleanup()
                checkErr(logFile.Close())
        }</span>

}

func (o *RootOptions) LogfilePostRun(*cobra.Command, []string) <span class="cov0" title="0">{
        if o.logfileCleanup != nil </span><span class="cov0" title="0">{
                o.logfileCleanup()
        }</span>
}

func checkErr(err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatal(err)
        }</span>
}

type MirrorOptions struct {
        *RootOptions
        OutputDir                  string
        ConfigPath                 string
        SkipImagePin               bool
        ManifestsOnly              bool
        From                       string
        ToMirror                   string
        UserNamespace              string
        DryRun                     bool
        SourceSkipTLS              bool
        DestSkipTLS                bool
        SourcePlainHTTP            bool
        DestPlainHTTP              bool
        SkipVerification           bool
        SkipCleanup                bool
        SkipMissing                bool
        SkipMetadataCheck          bool
        ContinueOnError            bool
        IgnoreHistory              bool
        MaxPerRegistry             int
        UseOCIFeature              bool
        OCIRegistriesConfig        string
        OCIInsecureSignaturePolicy bool
        // cancelCh is a channel listening for command cancellations
        cancelCh         &lt;-chan struct{}
        once             sync.Once
        continuedOnError bool
        loglevel         string
        //remoteRegFuncs   RemoteRegFuncs
}

func (o *MirrorOptions) BindFlags(fs *pflag.FlagSet) <span class="cov0" title="0">{
        fs.StringVarP(&amp;o.ConfigPath, "config", "c", o.ConfigPath, "Path to imageset configuration file")
        fs.StringVarP(&amp;o.loglevel, "loglevel", "l", o.loglevel, "Log level one of (info, debug, trace, error)")
        fs.BoolVar(&amp;o.DryRun, "dry-run", o.DryRun, "Print actions without mirroring images")
        fs.BoolVar(&amp;o.SkipVerification, "skip-verification", o.SkipVerification, "Skip verifying the integrity of the retrieved content."+
                "This is not recommended, but may be necessary when importing images from older image registries."+
                "Only bypass verification if the registry is known to be trustworthy.")
        fs.BoolVar(&amp;o.ContinueOnError, "continue-on-error", o.ContinueOnError, "If an error occurs, keep going "+
                "and attempt to complete operations if possible")
        fs.BoolVar(&amp;o.SkipMissing, "skip-missing", o.SkipMissing, "If an input image is not found, skip them. "+
                "404/NotFound errors encountered while pulling images explicitly specified in the config "+
                "will not be skipped")
}</span>

func (o *MirrorOptions) init() <span class="cov0" title="0">{
        o.cancelCh = makeCancelCh(syscall.SIGINT, syscall.SIGTERM)
}</span>

// CancelContext will return a cancellable context and listen for
// cancellation signals
func (o *MirrorOptions) CancelContext(parent context.Context) (context.Context, context.CancelFunc) <span class="cov0" title="0">{
        o.once.Do(o.init)
        ctx, cancel := context.WithCancel(parent)
        go func() </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-o.cancelCh:<span class="cov0" title="0">
                        cancel()</span>
                case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                }
        }()
        <span class="cov0" title="0">return ctx, cancel</span>
}

// makeCancelCh creates an interrupt listener for os signals
// and will send a message on a returned channel
func makeCancelCh(signals ...os.Signal) &lt;-chan struct{} <span class="cov0" title="0">{
        resultCh := make(chan struct{})
        signalCh := make(chan os.Signal, 1)
        signal.Notify(signalCh, signals...)
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        &lt;-signalCh
                        resultCh &lt;- struct{}{}
                }</span>
        }()
        <span class="cov0" title="0">return resultCh</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package services

import (
        "bufio"
        "context"
        "encoding/json"
        "os"
        "strings"

        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha3"
)

func (o *Executor) ExecuteRelease(ctx context.Context) error <span class="cov0" title="0">{

        mo := MirrorOptions{}
        writer := bufio.NewWriter(os.Stdout)

        releaseOpts := NewReleaseOptions(&amp;mo)
        releases := releaseOpts.Run(ctx, &amp;o.Config)

        for key := range releases </span><span class="cov0" title="0">{
                //args := []string{dockerProtocol + key, ociProtocol + workingDir + releaseImageDir, "true"}
                o.Log.Info("copying image %s ", key)
                src := dockerProtocol + key
                dest := ociProtocol + workingDir + releaseImageDir
                err := o.Mirror.Run(ctx, src, dest, &amp;o.Opts, writer)
                if err != nil </span><span class="cov0" title="0">{
                        o.Log.Error(" %v ", err)
                }</span>
        }

        <span class="cov0" title="0">oci, err := o.Manifest.GetImageIndex(workingDir + releaseImageDir)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error(" %v ", err)
                return err
        }</span>

        //read the link to the manifest
        <span class="cov0" title="0">manifest := strings.Split(oci.Manifests[0].Digest, ":")[1]
        o.Log.Info("manifest %v", manifest)

        oci, err = o.Manifest.GetImageManifest(workingDir + releaseImageDir + blobsDir + manifest)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error(" %v ", err)
                return err
        }</span>

        <span class="cov0" title="0">err = o.Manifest.ExtractLayersOCI(releaseImageExtractDir, releaseManifests, oci)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error(" %v ", err)
        }</span>

        <span class="cov0" title="0">var release = v1alpha3.ReleaseSchema{}

        file, _ := os.ReadFile(workingDir + releaseImageExtractFullPath)
        err = json.Unmarshal([]byte(file), &amp;release)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error("Unmarshaling to struct %v", err)
        }</span>

        <span class="cov0" title="0">var allImages []v1alpha3.RelatedImage
        for _, item := range release.Spec.Tags </span><span class="cov0" title="0">{
                o.Log.Info("  %s ", item.Name)
                allImages = append(allImages, v1alpha3.RelatedImage{Image: item.Name})
        }</span>

        <span class="cov0" title="0">var batch *BatchSchema
        images := len(release.Spec.Tags)
        if images &lt; BATCH_SIZE </span><span class="cov0" title="0">{
                batch = &amp;BatchSchema{items: images, count: 1, batchSize: images, batchIndex: 0, remainder: 0}
        }</span> else<span class="cov0" title="0"> {
                batch = &amp;BatchSchema{items: images, count: (images / BATCH_SIZE), batchSize: BATCH_SIZE, remainder: (images % BATCH_SIZE)}
        }</span>
        <span class="cov0" title="0">batch.copyImages = allImages
        batch.Writer = writer

        //TODO
        // add these in the BatchWorker
        // src := dockerProtocol + release.Spec.Tags[index].From.Name
        //        dest := strings.Split(release.Spec.Tags[index].From.Name, ":")[1]

        //call the batch executioner
        err = o.BatchWorker(ctx, batch, o.Opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if batch.remainder &gt; 0 </span><span class="cov0" title="0">{
                batch.batchIndex = batch.count
                batch.count = batch.remainder
                batch.batchSize = 1
                err := o.BatchWorker(ctx, batch, o.Opts)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">writer.Flush()
        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
